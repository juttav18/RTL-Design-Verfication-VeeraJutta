module spi_master (
    input wire clk,
    input wire rst,
    input wire tx_en,
    output reg mosi,
    output reg cs,
    output wire sclk
);

    typedef enum logic {idle = 0, tx_data = 1} state_type;

    state_type state;

    reg spi_sclk = 0;
    reg [2:0] ccount;       // Clock divider counter
    reg [3:0] count;        // Bit counter
    reg [7:0] din = 8'hAA;  // Data to transmit

    // SPI clock generation
    always @(posedge clk) begin
        if (rst) begin
            ccount <= 0;
            spi_sclk <= 0;
        end else if (tx_en) begin
            if (ccount < 3)
                ccount <= ccount + 1;
            else begin
                ccount <= 0;
                spi_sclk <= ~spi_sclk;
            end
        end
    end

    // State machine for SPI master
    always @(posedge sclk) begin
        case (state)
            idle: begin
                mosi <= 1'b0;
                cs <= 1'b1;
                count <= 0; // Reset bit counter in idle state
                if (tx_en) begin
                    state <= tx_data;
                    cs <= 1'b0;
                end else begin
                    state <= idle;
                end
            end

            tx_data: begin
                if (count < 8) begin
                    mosi <= din[7 - count]; // Transmit MSB first
                    count <= count + 1;
                    state <= tx_data;
                end else begin
                    state <= idle;
                    mosi <= 1'b0;
                    cs <= 1'b1;
                    count <= 0; // Reset bit counter for the next transaction
                end
            end

            default: state <= idle;
        endcase
    end

    assign sclk = spi_sclk;

endmodule


module spi_slave (
    input wire sclk,
    input wire mosi,
    input wire cs,
    output reg done,
    output [7:0] dout
);

    typedef enum logic {idle = 0, sample = 1} state_type;

    state_type state;

    reg [7:0] data = 8'b0;  // Data register to store received bits
    reg [3:0] count;        // Bit counter

    always @(negedge sclk) begin
        case (state)
            idle: begin
                done <= 1'b0;
                if (cs == 1'b0) begin
                    state <= sample;
                end else begin
                    state <= idle;
                end
            end

            sample: begin
                if (count < 8) begin
                    data <= {data[6:0], mosi}; // Shift in data from MOSI
                    count <= count + 1;
                    state <= sample;
                end else begin
                    count <= 0;
                    state <= idle;
                    done <= 1'b1; // Indicate data reception is complete
                end
            end

            default: state <= idle;
        endcase
    end

    assign dout = data;

endmodule
