module top();
    
    reg ready = 1;
    integer spi_edges = 0;
    reg sclk = 1;
    reg cpol = 1;
    reg [1:0]ccount = 0;
    reg clk = 0;
    reg start = 0;
    
    always #5 clk = ~clk;
    
    initial begin
        @(posedge clk);
        start = 1;
        @(posedge clk);
        start = 0;
    end
    
    always@(posedge clk)begin
        if(start)begin
            ready <= 1'b0;
            spi_edges <= 16;
            sclk <= cpol;
        end
        else if (spi_edges > 0)begin
            if (ccount == 1)begin
                ccount <= ccount + 1;
                spi_edges <= spi_edges - 1;
                sclk <= ~sclk;
            end
            else if (ccount == 3)begin
                ccount <= ccount + 1;
                spi_edges <= spi_edges - 1;
                sclk <= ~sclk;
            end
            else ccount <= ccount + 1;
        end
        else begin
            ready <= 1'b1;
            sclk <= cpol;
        end
    end
    
    reg [2:0]state = 0;
    reg cpha = 0;
    reg cs = 1'b1;
    integer count = 0;
    reg [2:0]bit_count = 3'b111;
    reg [7:0]tx_data = 8'b10101010;
    reg mosi = 1'b0;
    
    always@(posedge clk)begin
        case(state)
            0: begin
                if (start) begin
                    if (!cpha) begin
                        state <= 1;
                        cs <= 1'b0;
                    end
                    else begin
                        state <= 3;
                        cs <= 1'b0;
                    end
                end
                else state <= 0;
            end
            
            1: begin
                if(count < 3)begin
                    count <= count + 1;
                    mosi <= tx_data[bit_count];
                    state <= 1;
                end
                else begin
                    count <= 0;
                    if ( bit_count != 0)begin
                        bit_count <= bit_count - 1;
                        state <= 1;
                    end
                    else state <= 2;
                end
            end
            
            2: begin
                state <= 0;
                mosi <= 1'b0;
                cs <= 1'b1;
                bit_count <= 3'b111;
            end
            
            3: begin
                state <= 4;
            end
            
            4: begin
                state <= 1;
            end
            
            default: state <= 0;
            
        endcase
    end
    
    reg [7:0]rx_data;
    integer r_count = 0;
    
    always@(posedge sclk)begin
        if (cs == 0) begin
            if (r_count<8)begin
                rx_data <= {rx_data[6:0],mosi};
                r_count <= r_count + 1;
            end
            else begin
                r_count <= 0;
            end
        end
    end
    
endmodule
